(module std.hashmap
  (import std)
  (import std.array)
  (import std.combinator)
  (import std.math)
  (import std.tuple)

  (var :hashmap (sym-new "hashmap"))
  (fun hashmap-make (hasher equal buckets len max-load)
    (tuple-6 :hashmap hasher equal 
      (ref-new buckets) (ref-new len) (ref-new max-load)))
  (fun hashmap? (h)
    (and (tuple-6? h) (eqv? (get-0 h) :hashmap)))

  (fun hashmap-hasher (h) (get-1 h))
  (fun hashmap-equal (h) (get-2 h))
  (fun hashmap-buckets (h) (ref-get (get-3 h)))
  (fun hashmap-set-buckets! (h buckets) (ref-set! (get-3 h) buckets))
  (fun hashmap-len (h) (ref-get (get-4 h)))
  (fun hashmap-set-len! (h len) (ref-set! (get-4 h) len))
  (fun hashmap-max-load (h) (ref-get (get-5 h)))
  (fun hashmap-set-max-load! (h load) (ref-set! (get-5 h) (max 0 (min 1 load))))

  (fun hashmap-empty? (h)
    (== 0 (hashmap-len h)))
  (export hashmap-len hashmap-empty? hashmap-max-load hashmap-set-max-load!)

  (fun hashmap-hash (h key)
    ((hashmap-hasher h) key))

  (fun bucket-make (hash key value)
    (tuple-3 hash key value))
  (fun bucket-hash (b) (get-0 b))
  (fun bucket-key (b) (get-1 b))
  (fun bucket-value (b) (get-2 b))

  (fun hashmap-new (hasher equal)
    (hashmap-make hasher equal (array-new-filled 8 false) 0 0.8))
  (export hashmap-new hashmap?)

  (fun lookup (h key found not-found)
    (let ((key-hash (hashmap-hash h key))
          (equal (hashmap-equal h))
          (buckets (hashmap-buckets h))
          (bucket-count (array-len buckets)))
      (fun distance-to-init (index hash)
        (mod (- index hash) bucket-count))
      (fun walk (probe)
        (let ((index (mod (+ probe key-hash) bucket-count))
              (bucket (array-get buckets index)))
          (if bucket
            (let ((hash (bucket-hash bucket))
                  (distance (distance-to-init index hash)))
              (cond ((and (== hash key-hash) (equal key (bucket-key bucket)))
                      (found bucket))
                    ((> distance probe)
                      (not-found))
                    (true
                      (walk (+ probe 1)))))
            (not-found))))
      (walk 0)))

  (fun hashmap-get-or (h key not-found)
    (lookup h key bucket-value not-found))
  (fun hashmap-get (h key)
    (lookup h key bucket-value (lambda () (/ 1 0))))
  (fun hashmap-contains? (h key)
    (lookup h key (constant-1 true) (constant-0 false)))
  (export hashmap-get-or hashmap-get hashmap-contains?)

  (fun insert-key-value (h key value)
    (let ((key-hash (hashmap-hash h key)))
      (insert h key-hash key value (bucket-make key-hash key value))))
  (fun insert-bucket (h bucket)
    (insert h (bucket-hash bucket) (bucket-key bucket) (bucket-value bucket) bucket))
  (fun insert (h key-hash key value inserted-bucket)
    (check-rehash h (+ 1 (hashmap-len h)))
    (let ((equal (hashmap-equal h))
          (buckets (hashmap-buckets h))
          (bucket-count (array-len buckets)))
      (fun distance-to-init (index hash)
        (mod (- index hash) bucket-count))
      (fun walk (probe key-hash key value inserted-bucket)
        (let ((index (mod (+ probe key-hash) bucket-count))
              (bucket (array-get buckets index)))
          (if bucket
            (let ((hash (bucket-hash bucket))
                  (distance (distance-to-init index hash)))
              (cond ((and (== hash key-hash) (equal key (bucket-key bucket)))
                      (array-set! buckets index inserted-bucket)
                      false)
                    ((< distance probe)
                      (array-set! buckets index inserted-bucket)
                      (walk (+ distance 1) hash (bucket-key bucket)
                        (bucket-value bucket) bucket))
                    (true
                      (walk (+ probe 1) key-hash key value inserted-bucket))))
            (begin
              (array-set! buckets index inserted-bucket)
              true))))
      (when (walk 0 key-hash key value inserted-bucket)
        (hashmap-set-len! h (+ (hashmap-len h) 1)))))

  (fun check-rehash (h check-len)
    (let ((max-len (* (hashmap-max-load h) (array-len (hashmap-buckets h)))))
      (when (> check-len max-len)
        (let ((old-buckets (hashmap-buckets h))
              (new-len (max check-len (ceiling-int (* 2 (+ 1 max-len)))))
              (new-buckets (array-new-filled new-len false)))
          (hashmap-set-buckets! h new-buckets)
          (hashmap-set-len! h 0)
          (array-each old-buckets (lambda (bucket)
            (when bucket (insert-bucket h bucket))
            true))))))

  (fun hashmap-set! (h key value)
    (insert-key-value h key value))
  (export hashmap-set!)

  (fun remove (h key-hash key)
    (let ((equal (hashmap-equal h))
          (buckets (hashmap-buckets h))
          (bucket-count (array-len buckets)))
      (fun distance-to-init (index hash)
        (mod (- index hash) bucket-count))
      (fun lookup-walk (probe)
        (let ((index (mod (+ probe key-hash) bucket-count))
              (bucket (array-get buckets index)))
          (if bucket
            (let ((hash (bucket-hash bucket))
                  (distance (distance-to-init index hash)))
              (cond ((and (== hash key-hash) (equal key (bucket-key bucket)))
                      (back-shift index (mod (+ index 1) bucket-count))
                      true)
                    ((< distance probe)
                      false)
                    (true
                      (lookup-walk (+ 1 probe)))))
            false)))
      (fun back-shift (index next-index)
        (let ((next-bucket (array-get buckets next-index)))
          (cond ((not next-bucket)
                  (array-set! buckets index false))
                ((== (mod (bucket-hash next-bucket) bucket-count) next-index)
                  (array-set! buckets index false))
                (true
                  (array-set! buckets index next-bucket)
                  (back-shift next-index (mod (+ next-index 1) bucket-count))))))
      (when (lookup-walk 0)
        (hashmap-set-len! h (- (hashmap-len h) 1)))))

  (fun hashmap-remove! (h key)
    (remove h (hashmap-hash h key) key))
  (export hashmap-remove!)

  (fun to-list (buckets)
    (let ((bucket-count (array-len buckets)))
      (fun go (i acc)
        (if (< i bucket-count)
          (let ((bucket (array-get buckets i)))
            (go (+ i 1) (cons (cons (bucket-key bucket) (bucket-value bucket)) acc)))
          acc))
      (go 0 null)))

  (fun hashmap-to-list (h)
    (to-list (hashmap-buckets h))))
