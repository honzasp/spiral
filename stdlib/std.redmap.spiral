(module std.redmap
  (import std)
  (import std.combinator)
  (import std.cons)
  (import std.string)
  (import std.tuple)

  (var :red (sym-new "red"))
  (var :black (sym-new "black"))
  (var :black-black (sym-new "black-black"))

  (fun node-make (key value color left right)
    (tuple-5 key value color left right))
  (fun node-key (node) (get-0 node))
  (fun node-value (node) (get-1 node))
  (fun node-color (node) (get-2 node))
  (fun node-left (node) (get-3 node))
  (fun node-right (node) (get-4 node))

  (var black-leaf (node-make false false :black false false))
  (var black-black-leaf (node-make false false :black-black false false))

  (fun node-adopt (node left right)
    (unless (node-branch? node)
      (panic "leaves cannot adopt children"))
    (node-make (node-key node) (node-value node) (node-color node) left right))
  (fun node-adopt-color (node color left right)
    (unless (node-branch? node)
      (panic "leaves cannot adopt children and colorize"))
    (node-make (node-key node) (node-value node) color left right))
  (fun node-colorize (color node)
    (if (node-branch? node)
      (node-adopt-color node color (node-left node) (node-right node))
      (cond ((eqv? color :black) black-leaf)
            ((eqv? color :black-black) black-black-leaf)
            (true (panic "leaves cannot be colored red")))))

  (fun black-leaf? (node) (eqv? black-leaf node))
  (fun node-red? (node) (eqv? :red (node-color node)))
  (fun node-black? (node) (eqv? :black (node-color node)))
  (fun node-black-black? (node) (eqv? :black-black (node-color node)))
  (fun node-branch? (node) (not (not (node-left node))))

  (var :map (sym-new "map"))
  (fun map-make (root cmp)
    (tuple-3 :map root cmp))
  (fun map-root (m) (get-1 m))
  (fun map-cmp (m) (get-2 m))

  (fun map? (m)
    (and (tuple-3? m) (eqv? (get-0 m) :map)))
  (fun map-new (cmp)
    (map-make black-leaf cmp))
  (export map-new map?)

  (fun map-empty? (m)
    (black-leaf? (map-root m)))
  (export map-empty?)

  (fun map-len (m)
    (node-len (map-root m)))
  (fun node-len (n)
    (if (black-leaf? n) 0
      (+ 1 (+ (node-len (node-left n)) (node-len (node-right n))))))
  (export map-len)

  (fun map-get (m key)
    (map-get-or m key (constant-0 false)))
  (fun map-get-or (m key not-found)
    (node-find (map-root m) (map-cmp m) key identity not-found))
  (fun map-contains? (m key)
    (node-find (map-root m) (map-cmp m) key (constant-1 true) (constant-0 false)))
  (fun node-find (node cmp key found not-found)
    (if (node-branch? node)
      (let ((order (cmp (node-key node) key)))
        (cond ((> order 0) (node-find (node-left node) cmp key found not-found))
              ((< order 0) (node-find (node-right node) cmp key found not-found))
              (true        (found (node-value node)))))
      (not-found)))
  (export map-get map-get-or map-contains?)

  (fun balance-black (node)
    (let ((left (node-left node))
          (right (node-right node))
          (left-left (node-left left))
          (right-left (node-right left))
          (left-right (node-left right))
          (right-right (node-right right)))
      (cond ((and (node-red? left) (node-red? left-left))
              (node-adopt left
                (node-colorize :black left-left)
                (node-adopt node right-left right)))
            ((and (node-red? right) (node-red? right-right))
              (node-adopt right
                (node-adopt node left left-right)
                (node-colorize :black right-right)))
            ((and (node-red? left) (node-red? right-left))
              (node-adopt right-left
                (node-adopt-color left :black left-left (node-left right-left))
                (node-adopt node (node-right right-left) right)))
            ((and (node-red? right) (node-red? left-right))
              (node-adopt left-right
                (node-adopt node left (node-left left-right))
                (node-adopt-color right :black (node-right left-right) right-right)))
            (true node))))
  (fun balance-black-black (node)
    (let ((left (node-left node))
          (right (node-right node))
          (left-right (node-left right))
          (right-left (node-right left)))
      (cond ((and (node-red? left) (node-red? right-left))
              (node-adopt-color right-left :black
                (node-adopt-color left :black 
                  (node-left left)
                  (node-left right-left))
                (node-adopt-color node :black (node-right right-left) right)))
            ((and (node-red? right) (node-red? left-right))
              (node-adopt-color left-right :black
                (node-adopt-color node :black left (node-left left-right))
                (node-adopt-color right :black
                  (node-right left-right) (node-right right))))
            (true node))))
  (fun balance (node)
    (cond 
      ((node-black? node) (balance-black node))
      ((node-black-black? node) (balance-black-black node))
      (true node)))
  (fun blacken (node)
    (if (node-red? node)
      (node-colorize :black node)
      node))

  (fun map-set (m key value)
    (map-make (blacken (insert (map-root m) (map-cmp m) key value))
              (map-cmp m)))
  (fun insert (node cmp key value)
    (if (black-leaf? node)
      (node-make key value :red black-leaf black-leaf)
      (let ((order (cmp (node-key node) key)))
        (cond ((> order 0) (balance (node-adopt node 
                (insert (node-left node) cmp key value) (node-right node))))
              ((< order 0) (balance (node-adopt node
                (node-left node) (insert (node-right node) cmp key value))))
              (true
                (node-make key value (node-color node) 
                  (node-left node) (node-right node)))))))
  (export map-set)

  (fun rotate (node)
    (if (node-red? node) (rotate-red node) (rotate-black node)))
  (fun rotate-red (node)
    (let ((left (node-left node))
          (right (node-right node)))
      (cond ((node-black-black? left)
              (balance (node-adopt right
                (node-adopt node (node-colorize :black left) (node-left right))
                (node-right right))))
            ((node-black-black? right)
              (balance (node-adopt left
                (node-left left)
                (node-adopt node (node-right left) (node-colorize :black right)))))
            (true node))))
  (fun rotate-black (node)
    (let ((left (node-left node))
          (right (node-right node)))
      (cond ((and (node-black-black? left) (node-black? right))
              (balance (node-adopt-color right :black-black
                (node-adopt-color node :red
                  (node-colorize :black left) (node-left right))
                (node-right right))))
            ((and (node-black-black? right) (node-black? left))
              (balance (node-adopt-color left :black-black
                (node-left left)
                (node-adopt-color node :red
                  (node-right left)
                  (node-colorize :black right)))))
            ((and (node-black-black? left) (node-red? right))
              (node-adopt-color right :black
                (balance (node-adopt (node-left right)
                  (node-adopt-color node :red 
                    (node-colorize :black left)
                    (node-left (node-left right)))
                  (node-right (node-left right))))
                (node-right right)))
            ((and (node-black-black? right) (node-red? left))
              (node-adopt-color left :black
                (node-left left)
                (balance (node-adopt (node-right left)
                  (node-left (node-right left))
                  (node-adopt-color node :red
                    (node-right (node-right left))
                    (node-colorize :black right))))))
            (true node))))

  (fun remove-min (node)
    (let ((left (node-left node))
          (right (node-right node)))
      (if (black-leaf? left)
        (tuple-3 (node-key node) (node-value node)
          (if (black-leaf? right)
            (if (node-red? node) black-leaf black-black-leaf)
            (node-colorize :black right)))
        (let ((key-value-left (remove-min left)))
          (tuple-3 (get-0 key-value-left) (get-1 key-value-left)
            (rotate (node-adopt node (get-2 key-value-left) right)))))))
  (fun remove (cmp key node)
    (if (black-leaf? node)
      black-leaf
      (let ((left (node-left node))
            (right (node-right node))
            (order (cmp (node-key node) key)))
        (cond ((> order 0)
                (rotate (node-adopt node (remove cmp key left) right)))
              ((< order 0)
                (rotate (node-adopt node left (remove cmp key right))))
              ((not (black-leaf? right))
                (let ((min-key-value-right (remove-min right)))
                  (rotate (node-make 
                    (get-0 min-key-value-right) (get-1 min-key-value-right)
                    (node-color node) left (get-2 min-key-value-right)))))
              ((black-leaf? left)
                (if (node-black? node) black-black-leaf black-leaf))
              (true
                (node-colorize :black left))))))
  (fun map-remove (m key)
    (map-make (remove (map-cmp m) key (map-root m)) (map-cmp m)))
  (export map-remove)

  (fun map-from-assoc (cmp assoc)
    (fun iter (assoc map)
      (if (null? assoc) map
        (iter (cdr assoc) (map-set map (caar assoc) (cdar assoc)))))
    (iter assoc (map-new cmp)))
  (export map-from-assoc)

  (fun map-validate (map)
    (or (validate (map-cmp map) (map-root map))
        (let ((depth (validate-black-depth (map-root map))))
          (if (str? depth) depth false))))
  (fun validate (cmp node)
    (cond ((black-leaf? node) false)
          ((node-black-black? node) 
            (panic (str-cat-2 "a black black node is present: " (stringify node))))
          (true (validate-branch cmp node))))
  (fun validate-branch (cmp node)
    (let ((left (node-left node))
          (right (node-right node)))
      (cond
        ((and (node-branch? left) (>= (cmp (node-key left) (node-key node)) 0))
          (str-cat-2 "a left child does not have key lesser than its parent: "
                      (stringify node)))
        ((and (node-branch? right) (<= (cmp (node-key right) (node-key node)) 0))
          (str-cat-2 "a right child does not have key greater than its parent: "
                      (stringify node)))
        ((and (node-red? node) (node-red? left))
          (str-cat-2 "left child of a red node is red: " (stringify node)))
        ((and (node-red? node) (node-red? right))
          (str-cat-2 "right child of a red node is red: " (stringify node)))
        (true
          (or (validate cmp (node-left node)) (validate cmp (node-right node)))))))
  (fun validate-black-depth (node)
    (if (black-leaf? node) 0
      (let ((left-depth (validate-black-depth (node-left node)))
            (right-depth (validate-black-depth (node-right node))))
        (cond ((str? left-depth) left-depth)
              ((str? right-depth) right-depth)
              ((/= left-depth right-depth)
                (str-cat-6 "black depth mismatch " 
                  (stringify left-depth) " vs " (stringify right-depth) ": "
                  (stringify node)))
              (true
                (if (node-black? node) (+ 1 left-depth) left-depth))))))
  (export map-validate))
