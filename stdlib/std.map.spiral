(module std.map
  (import std)
  (import std.combinator)
  (import std.cons)
  (import std.string)
  (import std.tuple)

  (fun node-make (key value level left right)
    (tuple-5 key value level left right))
  (fun node-key (node) (get-0 node))
  (fun node-value (node) (get-1 node))
  (fun node-level (node) (get-2 node))
  (fun node-left (node) (get-3 node))
  (fun node-right (node) (get-4 node))

  (fun node-level-or-0 (node)
    (if node (node-level node) 0))

  (fun node-adopt (node left right)
    (node-make (node-key node) (node-value node) (node-level node) left right))

  (var :map (sym-new "map"))
  (fun map-make (root cmp)
    (tuple-3 :map root cmp))
  (fun map-root (m) (get-1 m))
  (fun map-cmp (m) (get-2 m))

  (fun map? (m)
    (and (tuple-3? m) (eqv? (get-0 m) :map)))
  (fun map-new (cmp)
    (map-make false cmp))
  (export map-new map?)

  (fun map-empty? (m)
    (if (map-root m) false true))
  (export map-empty?)

  (fun map-len (m)
    (node-len (map-root m)))
  (fun node-len (n)
    (if n (+ 1 (+ (node-len (node-left n)) (node-len (node-right n)))) 0))
  (export map-len)

  (fun map-get (m key)
    (map-get-or m key (lambda () (panic "key not found in map"))))
  (fun map-get-or (m key not-found)
    (node-find (map-root m) (map-cmp m) key identity not-found))
  (fun map-contains? (m key)
    (node-find (map-root m) (map-cmp m) key (constant-1 true) (constant-0 false)))
  (fun node-find (node cmp key found not-found)
    (if node
      (let ((order (cmp (node-key node) key)))
        (cond ((> order 0) (node-find (node-left node) cmp key found not-found))
              ((< order 0) (node-find (node-right node) cmp key found not-found))
              (true        (found (node-value node)))))
      (not-found)))
  (export map-get map-get-or map-contains?)

  (fun node-skew (node)
    (if (and node (node-left node)
             (== (node-level node) (node-level (node-left node))))
      (let ((left (node-left node))
            (left-left (node-left left))
            (right-left (node-right left))
            (right (node-right node)))
        (node-make (node-key left) (node-value left) (node-level node)
          left-left
          (node-make (node-key node) (node-value node) (node-level node)
            right-left right)))
      node))

  (fun node-split (node)
    (if (and node (node-right node) (node-right (node-right node)))
      (let ((right (node-right node))
            (right-right (node-right right)))
        (if (== (node-level node) (node-level right-right))
          (let ((left (node-left node))
                (left-right (node-left right)))
            (node-make (node-key right) (node-value right) (+ 1 (node-level node))
              (node-make (node-key node) (node-value node) (node-level node)
                left left-right)
              right-right))
          node))
      node))

  (fun map-set (m key value)
    (map-make (node-set (map-root m) (map-cmp m) key value)
              (map-cmp m)))
  (fun node-set (node cmp key value)
    (fun continue (left right)
      (node-split (node-skew
        (node-adopt node left right))))
    (if node
      (let ((order (cmp (node-key node) key)))
        (cond ((> order 0) 
                (continue (node-set (node-left node) cmp key value) (node-right node)))
              ((< order 0)
                (continue (node-left node) (node-set (node-right node) cmp key value)))
              (true
                (node-make key value (node-level node) 
                  (node-left node) (node-right node)))))
      (node-make key value 1 false false)))
  (export map-set)

  (fun node-decrease (node)
    (if node
      (let ((level (node-level node))
            (left (node-left node))
            (right (node-right node))
            (left-level (node-level-or-0 left))
            (right-level (node-level-or-0 right)))
        (if (or (< left-level (- level 1))
                (< right-level (- level 1)))
          (node-make (node-key node) (node-value node) (- level 1) left
            (if (>= right-level level)
              (node-make (node-key right) (node-value right) (- level 1)
                (node-left right) (node-right right))
              right))
          node))
      node))
  (fun node-split-right (node)
    (node-adopt node
      (node-left node) (node-split (node-right node))))
  (fun node-skew-right (node)
    (node-adopt node (node-left node) (node-skew (node-right node))))
  (fun node-skew-right-right (node)
    (if (node-right node)
      (let ((right (node-right node))
            (right-right (node-right right)))
        (node-adopt node (node-left node)
          (node-make (node-key right) (node-value right) (node-level right)
            (node-left right) (node-skew right-right))))
      node))
  (fun node-find-rightmost (node)
    (if (node-right node)
      (node-find-rightmost (node-right node))
      node))

  (fun map-remove (m key)
    (map-make (node-remove (map-root m) (map-cmp m) key)
              (map-cmp m)))
  (fun node-remove (node cmp key)
    (fun rebalance (node)
      (node-split-right (node-split 
        (node-skew-right-right (node-skew-right (node-skew 
          (node-decrease node)))))))
    (fun continue (left right)
      (rebalance (node-adopt node left right)))
    (if node
      (let ((order (cmp (node-key node) key))
            (left (node-left node))
            (right (node-right node)))
        (cond ((> order 0) (continue (node-remove left cmp key) right))
              ((< order 0) (continue left (node-remove right cmp key)))
              (left
                (let ((rightmost (node-find-rightmost left))
                      (leaf-key (node-key rightmost))
                      (leaf-value (node-value rightmost))
                      (new-left (node-remove left cmp leaf-key)))
                  (rebalance (node-make leaf-key leaf-value (node-level node)
                                        new-left right))))
              (true right)))
      node))
  (export map-remove)

  (fun map-from-assoc (cmp assoc)
    (fun iter (assoc map)
      (if (null? assoc) map
        (iter (cdr assoc) (map-set map (caar assoc) (cdar assoc)))))
    (iter assoc (map-new cmp)))
  (export map-from-assoc)

  (fun map-validate (map)
    (node-validate (map-cmp map) (map-root map)))
  (fun node-validate (cmp node)
    (if node
      (let ((left (node-left node))
            (right (node-right node))
            (level (node-level node))
            (left-level (node-level-or-0 left))
            (right-level (node-level-or-0 right)))
        (cond
          ((/= left-level (- level 1))
            (str-cat-2 "a left child has wrong level: " (stringify node)))
          ((> right-level level)
            (str-cat-2 "a right child has higher level than its parent: "
              (stringify node)))
          ((< right-level (- level 1))
            (str-cat-2 "a right child has level less than its parent minus one: "
                       (stringify node)))
          ((and right (<= level (node-level-or-0 (node-right right))))
            (str-cat-2 "a right grandchild does not have level less than its grandparent: "
                       (stringify node)))
          ((and left (>= (cmp (node-key left) (node-key node)) 0))
            (str-cat-2 "a left child does not have key lesser than its parent: "
                       (stringify node)))
          ((and right (<= (cmp (node-key right) (node-key node)) 0))
            (str-cat-2 "a right child does not have key greater than its parent: "
                       (stringify node)))
          (true
            (or (node-validate cmp left) (node-validate cmp right)))))
      false))
  (export map-validate))
