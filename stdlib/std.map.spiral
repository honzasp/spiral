(module std.map
  (import std)
  (import std.cons)

  (import std.string)
  (import std.tuple)

  (fun node-make (key value level left right)
    (tuple-5 key value level left right))
  (fun node-key (node) (get-0 node))
  (fun node-value (node) (get-1 node))
  (fun node-level (node) (get-2 node))
  (fun node-left (node) (get-3 node))
  (fun node-right (node) (get-4 node))

  (fun map-make (root cmp)
    (tuple-3 "map" root cmp))
  (fun map-root (m) (get-1 m))
  (fun map-cmp (m) (get-2 m))

  (fun map? (m)
    (and (tuple-3? m) (eqv? (get-0 m) "map")))
  (fun map-new (cmp)
    (map-make false cmp))
  (export map-new map?)

  (fun map-len (m)
    (node-len (map-root m)))
  (fun node-len (n)
    (if n (+ 1 (+ (node-len (node-left n)) (node-len (node-right n)))) 0))
  (export map-len)

  (fun map-get (m key)
    (map-get-or m key (lambda () false)))
  (fun map-get-or (m key not-found)
    (node-get (map-root m) (map-cmp m) not-found key))
  (fun node-get (node cmp not-found key)
    (if node
      (let ((order (cmp (node-key node) key)))
        (cond ((< order 0) (node-get (node-left node) cmp not-found key))
              ((> order 0) (node-get (node-right node) cmp not-found key))
              (true        (node-value node))))
      (not-found)))
  (export map-get map-get-or)

  (fun node-skew (node)
    (if (and node (node-left node)
             (== (node-level node) (node-level (node-left node))))
      (let ((left (node-left node))
            (left-left (node-left left))
            (right-left (node-right left))
            (right (node-right node)))
        (node-make (node-key left) (node-value left) (node-level node)
          left-left
          (node-make (node-key node) (node-value node) (node-level node)
            right-left right)))
      node))

  (fun node-split (node)
    (if (and node (node-right node) (node-right (node-right node)))
      (let ((right (node-right node))
            (right-right (node-right right)))
        (if (== (node-level right) (node-level right-right))
          (let ((left (node-left node))
                (left-right (node-left right)))
            (node-make (node-key right) (node-value right) (+ 1 (node-level node))
              (node-make (node-key node) (node-value node) (node-level node)
                left left-right)
              right-right))
          node))
      node))

  (fun map-set (m key value)
    (map-make (node-set (map-root m) (map-cmp m) key value)
              (map-cmp m)))
  (fun node-set (node cmp key value)
    (fun make (left right)
      (let ((key (node-key node))
            (value (node-value node))
            (level (node-level node)))
        (node-skew (node-split
          (node-make key value level left right)))))
    (if node
      (let ((order (cmp (node-key node) key)))
        (cond ((< order 0) 
                (make (node-set (node-left node) cmp key value) (node-right node)))
              ((> order 0)
                (make (node-left node) (node-set (node-right node) cmp key value)))
              (true
                (node-make key value (node-level node) 
                  (node-left node) (node-right node)))))
      (node-make key value 1 false false)))
  (export map-set)

  (fun map-from-assoc (cmp assoc)
    (fun iter (assoc map)
      (if (null? assoc) map
        (iter (cdr assoc) (map-set map (caar assoc) (cdar assoc)))))
    (iter assoc (map-new cmp)))
  (export map-from-assoc))
