\chapter{The translation pipeline}

The compiler parses the source code into a general s-expression structure and
transforms it into the Spiral syntax tree. All modules and the main program are
merged and translated into continuation-passing style in the first intermediate
language Spine. The next step converts Spine into the next intermediate
language, imperative Grit. The optimization passes then operate on Grit and then
the code generator emits assembly.

\section{S-expressions}

S-expressions are read using a simple hand-written parser. The resulting data
structure serves as an input to further processing. There is also a
pretty-printer to translate the s-expression back to textual form. Spine and
Grit can be read from s-expressions and written to them for the purposes of
testing and debugging.

\section{Spiral}

Syntax tree of Spiral is decoded from s-expression using a simple but tedious
process. If the program contains syntax errors, the compiler detects them in
this phase and rejects the program. Imported modules are collected in a pass
through the tree, loaded and also examined in the same way. Then the compiler
computes a topological ordering of the modules for further processing, producing
an error if the dependency graph is cyclic.

\section{Spine}

The first intermediate language is Spine. This language is derived from
$\lambda^U_\text{CPS}$ \cite{kennedy2007compiling} and based on
$\lambda$-calculus and continuation passing style.

Continuation is a special $\lambda$-value that cannot escape the local function
and never returns. Calling a continuation is equivalent to jumping to a basic
block in an imperative language or SSA form (single static assignment).
Functions take a return continuation as an argument and return value to the
caller by jumping to this continuation.

\begin{gram}
<program>   = (program <cont-name> <term>)
<term>      = (letcont <cont-def>... <term>)
            | (letfun <fun-def>... <term>)
            | (letobj <obj-def> <term>)
            | (call <val> <cont-name> <val>...)
            | (extern-call <extern-name> <cont-name> <val>...)
            | (cont <cont-name> <val>...)
            | (branch <boolval> <cont-name> <cont-name>)
<fun-def>   = (<var> <cont-name> (<var>...) (<var>...) <term>)
<cont-def>  = (<cont-name> (<var>...) <term>)
<obj-def>   = (string <var> <string-literal>)
            | (double <var> <double-literal>)
<val>       = <var> | <int-literal> | (true) | (false)
<boolval>   = (is-true <val>) | (is-false <val>)
\end{gram}

A program is defined by a term and a halting continuation. Jump to the halting
continuation terminates the program.

\begin{description}
\item[\texttt{(cont <cont-name> <arg>...)}] jumps to the given continuation,
  passing the given arguments. The number of arguments on the call site must
  match the definition of the continuation..

\item[\texttt{(branch <boolval> <then-name> <else-name>)}] evaluates a boolean
  value and jumps to one of the passed continuations. Both continuations must
  expect zero arguments.

\item[\texttt{(call <fun-val> <return-cont> <arg>...)}] calls the function with
  the given arguments, passing \texttt{<return-cont>} as the return
  continuation. This is a tail call If the continuation is also the caller's
  return continuation.

\item[\texttt{(extern-call <extern-name> <return-cont> <arg>...)}] calls an
  extern function by its name and passes its result to \texttt{<return-cont>}.
  Extern calls are never translated as tail calls.

\item[\texttt{(letcont (<cont-name> (<arg>...) <body>)... <term>)}] defines
  a group of mutually recursive continuations.

\item[\texttt{(letfun (<fun> <ret-cont> (<capture>...) (<arg>...) <body>)...
  <term>)}] defines mutually recursive functions. The function can use variables
  visible at the definition, but must list them in the capture list.
  However, no continuations from the outer context are available in the
  function.

\item[\texttt{(letobj <obj-def> <term>)}] defines an object (string or a real
  number).
\end{description}

All values (\texttt{<val>}) are atomic (variables or constants) and can be
duplicated with no restriction, as their evaluation is free.

\subsection{Translation from Spiral}

Translating expressions from Spiral to Spine requires converting the program
from direct style to continuation-passing style. The translation is driven by a
pair of functions, \texttt{translate-expr :: SpiralExpr -> (Onion, SpineVal)}
and \texttt{translate-expr-tail :: SpineContName -> SpiralExpr -> SpineTerm}.

\texttt{translate-expr} translates the Spiral expression as an
,,onion''\footnote{The author is to be blamed for this name.} and a value.
The onion consists of layers of \texttt{letcont}, \texttt{letfun} and
\texttt{letobj} Spine terms. Inside, the value of the Spiral expression is
evaluated to the returned Spine value.

The other function \texttt{translate-expr-tail} translates the Spiral expression
into a Spine term that jumps to the passed continuation with the evaluated value
of the expression. As an example, tail-calls are translated this way.

To illustrate these functions, we consider the translation of a simple snippet
in Spiral:

\begin{spiral}
(fun big-enough? (x)
  (if (< x 0)
    (println "small")
    (println "ok")))
\end{spiral}

First, we generate a name for the return continuation of the function
\texttt{big-enough?}, say \texttt{r}. To ensure that the calls in tail positions
will be translated correctly, returning directly to \texttt{r}, we pass the body
of the function (\texttt{(if (< x 0) (println "small") (println "ok"))}) to function
\texttt{translate-expr-tail "r"}.

To evaluate \texttt{if} expression, we must first evaluate the condition
\texttt{(< x 0)} using \texttt{translate-expr}. We obtain the onion
\texttt{(letcont (lt-ret (lt-result) ?) (call < lt-ret x 0))}, where the
question mark \texttt{?} represents the ,,hole'', that is the place where we can
get the result in variable \texttt{lt-result}.

We translate both arms in the \texttt{if} expression by
\texttt{translate-expr-tail} to preserve the tail calls and get Spine terms
\texttt{(letobj (string s1 "small") (call println r s1))} and \texttt{(letobj
(string s2 "ok") (call println r s2))}.

To generate the \texttt{branch} term, we need two continuations that would serve
as the targets of the conditional jump. We will call these continuations
\texttt{on-true} and \texttt{on-false} and set their bodies to the terms
we have generated from the \texttt{if} arms. The body of the translated function
then looks like this:

\begin{spine}
(letcont (lt-ret (lt-result)
            (letcont (on-true ()
                        (letobj (string s1 "small") (call println r s1)))
                     (on-false ()
                        (letobj (string s2 "ok") (call println r s2)))
              (branch (is-true lt-result) on-true on-false)))
  (call < lt-ret x 0))
\end{spine}

It is apparent that the order of evaluation and the flow of information from the
original program is explicit after the translation to Spine. We must first call
\texttt{<} with \texttt{x} and \texttt{0}. Then we get the result in
\texttt{lt-result} inside \texttt{lt-ret}, where we scrutinize the variable and
decide which branch will go next. In both branches we must first define the
string that we want to print and then pass it to \texttt{println}. Upon
returning, \texttt{println} will pass its result directly to our own caller, so
this is a tail-call.

\section{Grit}

Next stage of the pipeline is the language Grit. It is quite low-level and is
close to the assembler. All functions and objects are brought to the top level,
variables are mutable and named by integers. Functions are composed from basic
blocks, that contain a list of operations terminated by a jump.

\begin{gram}
<program>   = (program <fun-name> <fun-def>... <obj-def>...)
<fun-def>   = (fun <fun-name> <int> <int> <int> <label> <block>...)
<obj-def>   = (string <obj-name> <string-literal>)
            | (double <obj-name> <double-literal>)
<block>     = (<label> <op>... <jump>)

<op>        = (call <var> <callee> <val>...)
            | (extern-call <var> <extern-name> <val>...)
            | (alloc-clos (<var> <fun-name> <val>...)...)
            | (assign (<var> <val>)...)
<jump>      = (goto <label>)
            | (return <val>)
            | (tail-call <callee> <val>...)
            | (branch <boolval> <label> <label>)
<callee>    = (combinator <fun-name>)
            | (known-closure <fun-name> <val>)
            | (unknown <val>)

<val>       = (var <int>)
            | (arg <int>)
            | (capture <int>)
            | (combinator <fun-name>)
            | (obj <obj-name>)
            | (int <int>)
            | (true)
            | (false)
            | (undefined)
<boolval>   = (is-true <val>) | (is-false <val>)
\end{gram}

The operations represent all actions that the program can do:

\begin{description}
  \item[\texttt{(call <var> <callee> <arg>...)}] calls the function determined
    by \texttt{<callee>} with some arguments and writes the return value to a
    variable. \texttt{<callee>} can be:
    \begin{description}
      \item[\texttt{(combinator <fun-name>)}] calls a combinator, which is a
        function that has no captured variables. This call is very effective,
        because there is no need to store the function value and pass it to the
        callee at runtime. Furthermore, we can check the number of arguments
        during compilation, so the callee does not have to check them at
        runtime.
      \item[\texttt{(known-closure <fun-name> <val>)}] calls a closure that is
        known statically. To generate such a call, the compiler must be able to
        prove that \texttt{<val>} will only ever be a function object of the
        function \texttt{<fun-name>}, otherwise the behavior is undefined (and
        probably catastrophic). We need to store the function value, but we can
        jump directly to the function body and skip the argument check.
      \item[\texttt{(unknown <val>)}] is a fully dynamic call. At runtime, we
        must in the caller first check whether the value is a function and
        report an error otherwise. The callee will then check the number of
        arguments and also report an error if it does not match.
    \end{description}

  \item[\texttt{(extern-call <var> <extern-name> <arg>...)}] calls an external
    function and writes the result into the variable \texttt{<var>}.

  \item[\texttt{(alloc-clos (<var> <fun-name> <capture>...))}] allocates
    closures for functions with given names and list of captured values. The
    variables that hold the closure values are initialized before the captures
    are evaluated, so the functions can reference each other. As a special case,
    if the capture list is empty, no allocation is performed but the static
    function value of the combinator is produced.

  \item[\texttt{(assign (<var> <val>)...)}] rewrites the variables by
    corresponding values. The whole operation is atomic, so a variable assigned
    to on the left-hand side will be evaluated to its former value on the
    right-hand side.
\end{description}

The jumps are formed as following:

\begin{description}
  \item[\texttt{(goto <label>)}] jumps to the given block.
  \item[\texttt{(return <val>)}] returns a value from the function.
  \item[\texttt{(tail-call <callee> <arg>...)}] performs a tail-call to
    \texttt{<callee>} (with the same semantics as in \texttt{call}). The stack
    frame of the current function will be freed before the jump to the callee.
  \item[\texttt{(branch <boolval> <then> <else>)}] jumps to one of the two
    blocks depending on the boolean value.
\end{description}

There are more types of values than in Spine, but all values are either constant
or reachable by a single load from memory.

\begin{description}
  \item[\texttt{(var <index>)}] is value of a variable.
  \item[\texttt{(arg <index>)}] is value of an argument.
  \item[\texttt{(capture <index>)}] is value of a captured variable.
  \item[\texttt{(combinator <fun-name>)}] is the constant value of a combinator.
  \item[\texttt{(obj <obj-name>)}] is the constant value of a statically
    allocated object.
  \item[\texttt{(int <int>)}] is an integer constant.
  \item[\texttt{(true)}, \texttt{(false)}] are boolean constants.
  \item[\texttt{(undefined)}] is an undefined value. This special value can be
    produced by optimizations, for example as a result of a read from
    uninitialized variable. During the code generation, if an undefined value is
    assigned to a register or a memory location, no code is generated.
\end{description}

\subsection{Překlad z~jazyka Spine}

Překlad ze Spine do Gritu je poměrně přímočarý. Volání \emph{continuation} je
přeloženo jako přiřazení do proměnných vygenerovaných jako její argumenty a skok
do bloku, kterým tělo \emph{continuation} začíná. Ostatní konstrukce ve Spine
mají v~jazyku Grit přímý ekvivalent.

\subsection{Optimalizace}

Jelikož je jazyk Spiral poměrně chudý, nabízí se relativně málo možností
optimalizace. Proto se první optimalizační fáze aplikují až na nízkoúrovňový
Grit a jedná se převážně o zjednodušující a zeštíhlující proces.

\subsubsection{Optimalizace známých hodnot}

V~této fázi, která operuje nad celým programem, je určen odhad hodnot, kterých
může nabýt každá proměnná, zachycená proměnná a návratová hodnota. Tyto
informace jsou poté využity několikerým způsobem:

\begin{itemize}
  \item Optimalizace známých volání nahrazením \texttt{(call (unknown ...) ...)}
    za \texttt{(call (known-closure ...) ...)} nebo \texttt{(call (combinator
    ...) ...)}.
  \item Nahrazení větvení nepodmíněným skokem, pokud je možné dokázat, že
    testovací hodnota je vždy pravdivá nebo vždy nepravdivá.
  \item Propagace konstant odstraní proměnné, jejichž hodnota je konstantní
    (číslo, pravdivostní hodnota nebo staticky alokovaný objekt).
\end{itemize}

\subsubsection{Odstranění nepotřebných hodnot}

Tato fáze je opět globální a jejím účelem je převážně zrušit nepotřebné
zachycené hodnoty, ovšem zároveň je možno odstranit i zápisy do nevyužitých
proměnných a alokaci zbytečných funkcí. Často se stane, že funkce přijde o
všechny zachycené hodnoty, čímž se stane kombinátorem. Její použití pak již není
spojeno s~alokací paměti.

\subsubsection{Inlining funkcí}

Během fáze inliningu jsou volání vybraných funkcí nahrazena přímým vložením
volané funkce do funkce volající. Tato optimalizace je pro funkcionální programy
zcela klíčová, protože se většinou skládají z~velkého počtu malých funkcí.
Jejich expanzí na místo volání se ušetří instrukce pro manipulaci se zásobníkem
a pro samotné volání a návrat z~funkce. Zároveň je pak možné provést další
optimalizace, převážně proto, že jsou nyní zpravidla k~dispozici lepší informace
o argumentech volané funkce. Na druhou stranu takto dochází k~duplikaci kódu a
většinou tak i k~nárůstu délky výsledného programu.

Pro inlining jsou nyní vybírány funkce, které jsou dostatečně malé, jsou
kombinátory a nevolají jiné funkce kromě externích. Do této kategorie spadá
většina funkcí standardní knihovny, které obvykle pouze obalují externí volání
podpůrné běhové knihovny.

\subsubsection{Odstranění nepotřebných definic}

Tato optimalizace je známá rovněž jako odstranění mrtvého kódu (\emph{dead code
elimination}) a spočívá ve vynechání funkcí a staticky alokovaných objektů,
které nejsou referencovány z~hlavní funkce a jsou tedy zbytečné. Kromě
nepoužitých definic z~importovaných modulů jsou obvykle odstraněny i funkce,
jejichž volání byla všude inlinována.

\subsubsection{Pořadí optimalizací}

U optimalizačních fází je velmi důležité pořadí, v~jakém jsou na program
aplikovány. Optimalizace známých hodnot zanechá část proměnných a zachycených
hodnot bez využití. Tyto proměnné jsou následně odstraněny ve fázi odstranění
nepotřebných hodnot. Zároveň se takto zvýší počet kombinátorů, které můžeme
inlinovat. Po inliningu pak dostaneme řadu nepotřebných definic, které jsou
kandidáty na odstranění.

Úroveň optimalizací je možno ovlivnit z~argumentů příkazové řádky. Na úrovni 0
neprobíhá žádná optimalizace. Úroveň 1 zapne všechny optimalizace ve výše
uvedeném pořadí kromě inliningu, který je umožněn až od úrovně 2. Při úrovni 3
pak po inliningu následuje ještě jednou optimalizace známých hodnot a odstranění
nepotřebných hodnot.

\section{Alokace slotů}

Program v~Gritu typicky pracuje s~velkým množstvím proměnných. Bylo by ovšem
značným plýtváním pamětí, pokud bychom každé proměnné alokovali na zásobníku
zvláští prostor (slot), jelikož doba života proměnné je obvykle krátká a její
slot by byl většinu času nevyužit. Proto je žádoucí několika proměnným přiřadit
stejný slot, ovšem samozřejmě tak, aby nedošlo ke ztrátě informace, tedy aby
zápis do proměnné nepřepsal hodnotu jiné proměnné, ze které se bude později
číst.

Této fázi v~běžných překladačích odpovídá alokace registrů, ovšem náš generátor
kódu je zjednodušený, takže všechny proměnné umisťuje do paměti. Podobně jako
při alokaci registrů však můžeme použít přístup s~užitím barvení grafu
interference
\cite{chaitin1981register,chaitin1982register,briggs1994improvements}, ovšem
postup je jednodušší díky tomu, že počet barev (registrů) nemáme omezen, pouze
se jej snažíme minimalizovat. Proto stačí pouze sestavit graf interference a ten
pak hladovým algoritmem obarvit. U hladového algoritmu je klíčové pořadí,
v~jakém jsou vrcholy barveny. V~našem případě vrcholy barvíme v~pořadí podle
počtu vycházejících hran sestupně.

\section{Assembler}

Posledním krokem překladu je generování assembleru pro architekturu IA-32
z~jazyka Grit. Výsledný soubor obsahuje kód všech funkcí, staticky alokované
objekty a řetězce.  Kvůli podpoře koncových volání mají funkce jazyka Spiral
jinou volací konvenci (\emph{calling convention}) než funkce jazyka C. Argumenty
pro funkci v~C jsou totiž umístěny na zásobníku v~oblasti volající funkce, pro
koncová volání je však potřeba, aby z~volající funkce na zásobníku nic nezbylo,
argumenty proto musí volaná funkce dostat do své oblasti.

Zásobník ve funkci s~\texttt{N} sloty vypadá takto (relativně vůči vrcholu
zásobníku v~registru \texttt{\%esp}):

\begin{ttcode}
  4*N+4  :  return address
    4*N  :  slot 0 (argument 0)
  4*N-4  :  slot 1 (argument 1)
            ...
      8  :  slot (N-2)
      4  :  slot (N-1)
      0  :  closure value
\end{ttcode}

Volaná funkce dostane argumenty ve svých prvních slotech, které se nachází těsně
pod návratovou adresou (zapsanou instrukcí \texttt{call}). Ostatní sloty jsou
umístěny níž. Hodnota funkce je umístěna v~registru \texttt{\%ecx}, počet
argumentů u neznámých volání v~\texttt{\%eax}. Hodnotu z~\texttt{\%ecx} funkce
zapíše na začátek svého zásobníku, aby bylo možno projít zásobník při úklidu
paměti.  Návratovou hodnotu pak funkce zpět na místo volání předá v~registru
\texttt{\%eax}.

Volání funkce proběhne tak, že se argumenty umístí pod prostor obsazený volající
funkcí a instrukcí \texttt{call} se na zásobník uloží návratová adresa.  Při
koncovém volání argumenty přepíšou sloty volající funkce, zásobník se posune
zpátky nahoru a do funkce se provede skok (instrukcí \texttt{jmp}). Návratová
adresa tak zůstane nezměněna a při návratu z~koncové funkce dojde ke skoku do
původní volající funkce.

Jelikož všechny proměnné jsou uloženy v~paměti, může generátor kódu použít pevně
dané registry pro dočasné uložení hodnot. Registry \texttt{\%eax} a
\texttt{\%edx} se používají při přesunech hodnot v~paměti, v~registru
\texttt{\%ecx} je uložena hodnota aktuální funkce, která se využívá při
přístupu k~zachyceným hodnotám.  V~jistých speciálních případech je rovněž
využit i registr \texttt{\%ebx}. Dále funkce přistupuje k~registru
\texttt{\%edi}, ve kterém je uložen ukazatel na aktuální pozadí
(\texttt{Bg*}) běhové knihovny.
