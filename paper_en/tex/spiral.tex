\chapter{Description of the language Spiral}

The language itself is very simple, as it provides only modules, functions,
variables, basic branching and literals. Primitive operations (such as
addition or array access) are defined in the standard library and implemented as
calls to the runtime. Note that the identifiers like \texttt{+} or \texttt{*}
are not built-in operators but standard variables.

No assignment operator is needed because all variables are immutable. Some
objects from the standard library, for example arrays, are internally mutable.
As a convention, functions that mutate objects have are suffixed with an
exclamation mark (\texttt{array-set!}).

Tail-calls allow an unbound number of recursive calls without the danger of
stack overflow, so all iterations can be expressed as recursion. Functions are
first-class values as in other functional languages, so there is no limitation
on storing them to variables or passing them as arguments to other functions. A
function can refer to variables defined outside of the body of the function.
We store the functions as closures consisting of the address and the values of
captured variables.

\section{Grammar}

The syntax of Spiral is based on the syntax of Scheme \cite{scheme7}. Program is
written in the fully parenthesised prefix form of s-expressions that are simple
to parse and easy to write.

\subsection{Programs and modules}
\begin{ttcode}
<top-level>   = <program> | <module>
<program>     = (program <stmt>...)
<module>      = (module <ident> <decl>...)
<decl>        = (export <ident>...) | <stmt>
\end{ttcode}

A program consists of a sequence of statements that are executed in order. A
module can also contain exports denoting the names that the module provides to
other modules and programs.

~
\subsection{Statements}

Statements can define imported names, named functions or plain variables.

\begin{ttcode}
<stmt>        = (import <import-def>...)
              | (fun <ident> (<ident>...) <stmt>...)
              | (var <ident> <expr>)
              | <expr>
<import-def>  = <ident>
              | (only <import-def> <ident>...)
              | (except <import-def> <ident>...)
              | (prefix <import-def> <ident>)
\end{ttcode}

\begin{description}

\item[\texttt{(import <import-def>...)}] The import statement loads a module and
  gives access to its exported variables in the active context. Only selected
  names can be imported using \texttt{(only ...)}, names can be excluded using
  \texttt{(except ...)} or prefixed with an identifier using \texttt{(prefix
  ...)}.

  Examples of imports:

  \begin{itemize}
    \item \texttt{(import std std.math)} imports all names from modules
      \texttt{std} and \texttt{std.math}.
    \item \texttt{(import (only std + - *))} imports from \texttt{std} just the
      names \texttt{+}, \texttt{-} and \texttt{*}.
    \item \texttt{(import (except std.math sin cos))} imports
      from~\texttt{std.math} all names except \texttt{sin} and \texttt{cos}.
    \item \texttt{(import (prefix (only std.math div mod) m.))} imports from
      \texttt{std.math} names \texttt{div} and \texttt{mod} prefixed
      \texttt{m.} (so we can refer to them as \texttt{m.div} and \texttt{m.mod}).
  \end{itemize}

\item[\texttt{(fun <fun-name> (<arg>...) <body-stmt>...)}] defines a named
  function. Multiple named functions defined next to each other can be mutually
  recursive, because a function defined earlier can refer to the functions
  defined later, including itself.

\item[\texttt{(var <var-name> <value>)}] defines a variable. Variables cannot
  refer to themselves, because their values can be used only after they are
  defined.

\item[\texttt{<expr>}] -- an expression in place of a statement is evaluated. If
  it is the last statement in a sequence of statements, its value is used as the
  value of the whole sequence, otherwise it is ignored.

\end{description}

\subsection{Expressions}

All remaining constructs of the language are expressions returning a value. If
there is no reasonable value for an expression (e.g. an empty expression
\texttt{(begin)}), it evaluates to \texttt{false}.

\begin{gram}
<expr>        = (if <expr> <expr> <expr>)
              | (cond (<expr> <stmt>...)...)
              | (when <expr> <stmt>...)
              | (unless <expr> <stmt>...)
              | (do ((<ident> <expr> <expr>)...) (<expr> <stmt>...) <stmt>...)
              | (and <expr>...)
              | (or <expr>...)
              | (begin <stmt>...)
              | (let ((<ident> <expr>)...) <stmt>...)
              | (lambda (<ident>...) <stmt>...)
              | (<expr> <expr>...)
              | (extern <ident> <expr>...)
              | <integer-literal>
              | <float-literal>
              | <string-literal>
              | <character-literal>
\end{gram}

\begin{description}
  \item[\texttt{<integer-literal>}, \texttt{<float-literal>}] are numeric
    constants that evaluate to the number they denote. Digits can be separated
    by underscores and float literals can have an exponent.

  \item[\texttt{<character-literal>}] is a character literal in single quotes
    that evaluates to the integer value of the character.

  \item[\texttt{<string-literal>}] is a string literal in double quotes. Escape
    sequences from C are supported (for example \texttt{\textbackslash{}n} is
    newline, \texttt{\textbackslash{}"} is a quote).

  \item[\texttt{(if <condition> <then> <else>)}] is a conditional expression.
    The condition is evaluated and if it is true, the first branch is evaluated,
    otherwise the second branch is evaluated. All values except \texttt{false}
    are considered true.

  \item[\texttt{(when <condition> <body-stmt>...)}] evaluates the statements in
    the body only if the condition evaluates to true.

  \item[\texttt{(unless <condition> <body-stmt>...)}] is the counterpart of
    \texttt{when} that evaluates the body if the condition is false.
    
  \item[\texttt{(cond (<condition> <stmt>...)...)}] evaluates the statements of
    the first condition that evaluates to true.

  \item[\texttt{(and <expr>...)}] evaluates expressions from left to right and
    returns the value of the first expression that evaluates to false, or
    \texttt{true} if all were true.

  \item[\texttt{(or <expr>...)}] evaluates expression from left to right and
    returns the value of the first that evaluated to true.

  \item[\texttt{(let ((<var> <expr>)...) <body-stmt>...)}] evaluates the
    expressions, bounds the values to the variables and then evaluates the
    statements in the body.

  \item[\texttt{(lambda (<arg>...) <body-stmt>...)}] creates an anonymous
    function with the given arguments. The statements in the body can access
    variables defined outside the function.

  \item[\texttt{(<fun> <arg>...)}] denotes function call. All arguments are
    evaluated from left to right, then the function is evaluated and called. It
    is an error if the first expression does not evaluate to a function.

  \item[\texttt{(extern <fun-name> <arg>...)}] is an extern function call.
    Extern functions are defined in C and are mostly used in the standard
    library. The arguments and the existence of the function cannot be checked,
    so the language does not guarantee safety.

  \item[\texttt{(begin <body-stmt>...)}] evaluates all statements and returns
    the value of the last.

  \item[\texttt{(do ((<var> <init> <next>)...) (<exit-condition> <exit-stmt>...)
    <body-stmt>...)}] is a loop expression. At the beginning, initial values of
    the variables are evaluated and bound. Then, if the condition
    (\texttt{<exit-condition>}) evaluates to true, the loop ends with evaluating
    exit statements (\texttt{<exit-stmt>...}). Otherwise, the body statements
    (\texttt{<body-stmt>...}) are evaluated, then the variables are bound to the
    values of \texttt{<next>} and the condition is checked again.

    For example, the following program computes and prints the first hundred
    Fibonacci numbers and then finishes with \texttt{done}:

\begin{spiral}
(program
  (import std)
  (do ((f1 0 f1)
       (f2 1 (+ f1 f2))
       (i  1 (+ i 1)))
    ((>= i 100)
      (println "done"))
    (println f1)))
\end{spiral}
\end{description}

\section{Standard library and basic types}

Standardní knihovna definuje základní funkce. Jelikož program ve Spiral nemá
implicitně definovaná žádná jména, je import standardní knihovny prakticky
nutností.

\begin{description}
  \item[\texttt{std.core}] definuje základní operace s~čísly (\texttt{+},
    \texttt{mod}, \texttt{<}, \texttt{==}, ...), predikáty ekvivalence
    (\texttt{eqv?}, \texttt{equal?}) a základní funkci pro výstup
    (\texttt{println}).  Rovněž definuje logické proměnné \texttt{true} a
    \texttt{false} (jako hodnoty výrazů \texttt{(and)} a \texttt{(or)}).

  \item[\texttt{std.array}] poskytuje funkce pro práci s~poli
    (\texttt{array-new}, \texttt{array-push!}, \texttt{array-get},
    \texttt{array-empty?}, ...). Pole jsou indexována celými čísly od nuly a
    jejich délka i obsah jsou měnitelné.

  \item[\texttt{std.tuple}] umožňuje používat n-tice (\emph{tuples}), a to
    v~délce od 0 do 8 prvků. Modul definuje konstruktory (\texttt{tuple-2},
    ...), funkce pro přístup k~jednotlivým prvkům (\texttt{get-0},
    \texttt{get-2}) a predikáty (\texttt{tuple?}, \texttt{tuple-2?},
    \texttt{tuple-n?}, ...). Prvky n-tic jsou neměnitelné.

  \item[\texttt{std.cons}] definuje funkce pro práci s~páry (\emph{cons}), které
    se převážně používají ve formě spojových seznamů, kdy první prvek páru
    (\emph{car}) ukládá hodnotu prvního prvku seznamu a druhý prvek (\emph{cdr})
    odkazuje na zbytek seznamu. Konec seznamu reprezentuje speciální hodnota
    (\emph{null} či \emph{nil}), pro kterou je ve Spiral použito \texttt{false}.
    Tento modul definuje základní funkce pro práci s~páry (\texttt{cons},
    \texttt{car}, \texttt{cdr}, \texttt{cons?}, ...) i pro manipulaci se seznamy
    (\texttt{list?}, \texttt{list-len}, \texttt{list-append},
    \texttt{list-reverse}, ...). Páry jsou neměnné, což znamená, že není možno
    vytvořit kruhový seznam.

  \item[\texttt{std.string}] exportuje funkce pracující s~řetězci
    (\texttt{str-len}, \texttt{str-get}, \texttt{stringify}, \texttt{str-cat-2},
    \texttt{str-cat-3}, ...). Řetězce jsou neměnitelné a složené z~bytů.

  \item[\texttt{std.io}] slouží pro vstupní a výstupní operace
    (\emph{input/output}) se soubory a standardními proudy
    (\texttt{io-file-open}, \texttt{io-close}, \texttt{io-stdin},
    \texttt{io-write-line}, \texttt{io-read-line}, \texttt{io-read-number},
    ...).

  \item[\texttt{std.env}] poskytuje programu přístup k~argumentům z~příkazové
    řádky (\texttt{env-get-argv}) a k~proměnným prostředí (\texttt{env-get-var}).

  \item[\texttt{std.math}] implementuje základní matematické funkce jako
    \texttt{abs}, \texttt{neg}, \texttt{sin} nebo \texttt{atan-2}.

  \item[\texttt{std.test}] je minimalistická knihovna pro tvorbu jednotkových
    testů.
\end{description}

Modul \texttt{std} reexportuje základní definice (například \texttt{+} nebo
\texttt{car}) a je poskytován pro pohodlí programátora.

\section{Ovládání překladače z~příkazové řádky}

Překladač je možno ovládat pomocí argumentů na příkazové řádce:

\begin{description}
  \item[\texttt{-o}, \texttt{-{}-output}] umožňuje určit výstupní soubor.
    Výstup je jinak umístěn do stejného adresáře jako vstupní soubor se stejným
    jménem a příponou určenou podle typu výstupu.
  \item[\texttt{-I}, \texttt{-{}-include}] přidá adresář, ve kterém se hledají
    \texttt{import}ované moduly.
  \item[\texttt{-e}, \texttt{-{}-emit}] nastaví typ výstupu: \texttt{sexpr} přečte
    vstupní s-výraz a vypíše jej ve formátované podobě, \texttt{spiral} vypíše
    syntaktický strom Spiral v~interní podobě, \texttt{spine} a
    \texttt{grit} vypíšou program v~odpovídajícím mezijazyku jako s-výraz,
    \texttt{asm} vypíše vygenerovaný assembler v~interní podobě, \texttt{gas}
    vypíše assembler jako vstup pro GNU Assembler a \texttt{exec} program
    přeloží a slinkuje s~běhovou knihovnou (což je výchozí chování).
  \item[\texttt{-t}, \texttt{-{}-runtime}] určí soubor s~běhovou knihovnou, se
    kterou bude program slinkován.
  \item[\texttt{-{}-link-cmd}] nastaví linkovací program. Výchozí je \texttt{clang},
    který sám zavolá systémový linker tak, aby program správně slinkoval se
    standardní knihovnou jazyka C (\texttt{libc}).
  \item[\texttt{-{}-gas-cmd}] umožňuje změnit assembler místo výchozího
    \texttt{as}.
  \item[\texttt{-O}, \texttt{-{}-opt-level}] umožňuje nastavit úroveň optimalizace
    od 0 do 3.
\end{description}

\section{Příklady}

Na závěr uvádíme několik drobných programů napsaných v~jazyce Spiral.

\subsection{Počítání prvočísel}

Následující program vypíše prvních tisíc prvočísel. Funkce
\texttt{make-prime-gen} vytvoří generátor, tedy funkci, která při každém dalším
zavolání vrátí další prvočíslo. Tato funkce má interně uloženo pole doposud
nalezených prvočísel.

\begin{spiral}
(program
  (import std)
  (import std.array)
  (import std.test)

  (fun make-prime-gen ()
    (var primes (array-new))
    (lambda ()
      (fun find-next-prime (x)
        (fun check-prime (i)
          (var p (array-get primes i))
          (cond
            ((> (* p p) x) true)
            ((== (mod x p) 0) false)
            (true (check-prime (+ 1 i)))))
        (if (check-prime 1) x (find-next-prime (+ 2 x))))
      (cond
        ((== (array-len primes) 0)
          (array-push! primes 2) 2)
        ((== (array-len primes) 1)
          (array-push! primes 3) 3)
        (true 
          (var next-prime (find-next-prime (+ 2 (array-last primes))))
          (array-push! primes next-prime)
          next-prime))))

  (var gen (make-prime-gen))
  (do ((i 0 (+ i 1)))
    ((>= i 1000))
    (println (gen))))
\end{spiral}

\subsection{Počítání celých mocnin a odmocnin}

Tento program aproximuje $\sqrt[n]{x}$ Newtonovou metodou (funkce \texttt{root})
a počítá $x^n$ pomocí binárního umocňování (funkce \texttt{power}). Oba
algoritmy jsou poté otestovány pomocí knihovny \texttt{std.test}.

\begin{spiral}
(program
  (import std)
  (import std.math)
  (import std.test)

  (var min-del 0.000001)
  (fun root (n a)
    (fun iter (x)
      (var b (/ a (power (- n 1) x)))
      (var x-del (/ (- b x) n))
      (if (< (abs x-del) min-del) x (iter (+ x x-del))))
    (iter (* a 1.0)))
  (fun power (n a)
    (cond
      ((== n 0) 1)
      ((== n 1) a)
      ((== (mod n 2) 0) (square (power (div n 2) a)))
      (true (* a (square (power (div n 2) a))))))
  (fun square (a) (* a a))

  (var eps 0.00001)
  (test "powers" (lambda (t) 
    (assert-near-eq t eps (power 2 10) 100)
    (assert-near-eq t eps (power 3 2) 8)
    (assert-near-eq t eps (power 1 33) 33)))
  (test "roots" (lambda (t)
    (assert-near-eq t eps (root 3 1000) 10)
    (assert-near-eq t eps (root 2 49) 7)
    (assert-near-eq t eps (root 4 256) 4)))
  (test "powered roots" (lambda (t)
    (assert-near-eq t eps (power 2 (root 2 2)) 2)
    (assert-near-eq t eps (power 3 (root 3 100)) 100)
    (assert-near-eq t eps (power 2 (root 2 13)) 13)
    (assert-near-eq t 0.01 (power 5 (root 5 12345)) 12345))))
\end{spiral}
